Bias free shadow mapping!
So how do we get rid of acne without bias? Well... we still apply a bias, but directly in the shadow map, rather than the shader, meaning we completely avoid the extra ALU work when shading our scene!

Method 1 - Bias the depth stencil

Modern graphics APIs give you control over how exactly your rasterization is performed, and one such option is applying a slope bias to your depths!

In D3D11 simply add the last line, and now your depths will automatically be biased based on the slope of that particular fragment when capturing your shadow depths.

CD3D11_RASTERIZER_DESC shadowRastDesc( D3D11_DEFAULT );
shadowRastDesc.SlopeScaledDepthBias = 1.0f;
Only one small problem... this requires that you're actually using your depth buffer directly as your shadow map, which requires you to do NDC and linearization calculations in your shader which still adds complexity when doing PCF, and can still result in shadow artifacts due to rounding errors.

That's why it's common to see people using distances in their shadow maps instead which are generated by a very simple and practically zero cost pixel shader.

Interlude - Use Distances

So if we're using distances rather than hardware depths we're in the realm of pixel shaders and framebuffers/RTVs. Unfortunately now our depth stencil trick no longer works, since the bias is exclusively applied to the depth buffer/DSV and has no effect on our pixel shader... buuut what does our pixel shader even look like?

Here's a very simple HLSL example that applies to spot and point lights where PositionWS is our world space fragment position, and g_vEyePosition is the world space position of our light source.

float main( VSOutputDistanceTest input ) : SV_Target
{
    float d = distance( input.PositionWS, g_vEyePosition );
    return d;
}
We simply write to our framebuffer a single float component representing the world space distance.

Okay, so where is the magic. How do we get the optimal bias?

Method 2 - Bias The Distances

This all relies on one very very simple intrinsic function in HLSL and GLSL: fwidth

So fwidth basically is equal to abs(ddx(p))+abs(ddy(p)) in HLSL and we can use that to compute not only the slope of the fragment (basically the view space normal) but do so relative to the shadow map resolution!

Our new magical pixel shader now looks like the following:

float main( VSOutputDistanceTest input ) : SV_Target
{
    float d = distance( input.PositionWS, g_vEyePosition );
    return d + fwidth( d );
}
And that's it. Just sample from the texture this renders to in your scene's main pixel shader using something like the following for naive shadows:

shadTex.Sample(sampler, shadCoord) > length(fragPos, lightPos);

Or leverage hardware 4 sample bilinear PCF with a comparator and the correct samplercmp state:

shadTex.SampleCmpLevelZero(samplercmp, shadCoord, length(fragP, lightP));

And that's it. No bias in your shader. Just optimal bias in your shadow.

Method 2.5 - PCF Bias

So method 2 is all well and good, but there's a small problem. If we want to do extra PCF on top of naive shadow sampling or hardware PCF we're still likely to get soft acne where some of the outer PCF samples now suffer acne which gets average with non-acne samples.

The fix for this is disgustingly simple, and doesn't require us to change anything in our main scene's pixel shader (other than of course adding the extra samples with offsets for PCF).

So let's assume our PCF radius (i.e. the maximum offset +/- in texel units we are sampling PCF over) is some global or per-light constant float pcfRadius; and we expose this in both our shadow mapping pixel shader and our main scene pixel shader. The only thing we need to change in our shadow mapping pixel shader is this:

float main( VSOutputDistanceTest input ) : SV_Target
{
    float d = distance( input.PositionWS, g_vEyePosition );
    return d + fwidth( d ) * ( 1 + pcfRadius );
}
And that's it! Now we can choose any arbitrary radius from 0 texels for no PCF to N pixels and we will NEVER get shadow acne! I tested it up to something like +/- 3 texels, so a total of 7x7 (or 14x14 with the free hardware PCF bonus) and still no acne.

Now I will say this is an upper bound, which means we cover the worst case scenario for potential acne without overbiasing, but if you know your light will only be hitting lightly sloped surfaces you can lower the multiplier and reduce the (already minimal) haloing around texel-width objects in your scene.